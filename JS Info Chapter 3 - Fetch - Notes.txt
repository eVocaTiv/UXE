FETCH

A typical fetch request consists of two await calls:

let response = await fetch(url, options); // resolves with response headers
let result = await response.json(); // read body as json
Or, without await:

fetch(url, options)
  .then(response => response.json())
  .then(result => /* process result */)
Response properties:

response.status – HTTP code of the response,
response.ok – true is the status is 200-299.
response.headers – Map-like object with HTTP headers.
Methods to get response body:

response.text() – return the response as text,
response.json() – parse the response as JSON object,
response.formData() – return the response as FormData object (form/multipart encoding, see the next chapter),
response.blob() – return the response as Blob (binary data with type),
response.arrayBuffer() – return the response as ArrayBuffer (low-level binary data),
Fetch options so far:

method – HTTP-method,
headers – an object with request headers (not any header is allowed),
body – the data to send (request body) as string, FormData, BufferSource, Blob or UrlSearchParams object.
In the next chapters we’ll see more options and use cases of fetch.

Task - 1 - GOOD (but given solution gives error so don't fret).


FORMDATA

- <form id="formElem">
  <input type="text" name="name" value="John">
  <input type="text" name="surname" value="Smith">
  <input type="submit">
</form>
let resp = await fetch('...', {
	method: 'POST',
	body: newFormData(formElem)
})

The form is always sent as Content-Type: multipart/form-data, this encoding allows to send files. So, <input type="file"> fields are sent also, similar to a usual form submission.


FETCH - DOWNLOAD PROGRESS
To track download progress, we can use response.body property. It’s a ReadableStream 
Unlike response.text(), response.json() and other methods, response.body gives full control over the reading process, and we can count how much is consumed at any moment.

ABORTING A FETCH
let controller = new AbortController();
let signal = controller.signal;

// The party that performs a cancelable operation
// gets the "signal" object
// and sets the listener to trigger when controller.abort() is called
signal.addEventListener('abort', () => alert("abort!"));

// The other party, that cancels (at any point later):
controller.abort(); // abort!

// The event triggers and signal.aborted becomes true
alert(signal.aborted); // true


To be able to cancel fetch, pass the signal property of an AbortController as a fetch option:

let controller = new AbortController();
fetch(url, {
  signal: controller.signal
});


FETCH: CORS

From the browser point of view, there are two kinds of cross-origin requests: “safe” and all the others.

“Safe” requests must satisfy the following conditions:

Method: GET, POST or HEAD.
Headers – we can set only:
Accept
Accept-Language
Content-Language
Content-Type to the value application/x-www-form-urlencoded, multipart/form-data or text/plain.
The essential difference is that safe requTypical code of the GET-request with XMLHttpRequest:

let xhr = new XMLHttpRequest();

xhr.open('GET', '/my/url');

xhr.send();

xhr.onload = function() {
  if (xhr.status != 200) { // HTTP error?
    // handle error
    alert( 'Error: ' + xhr.status);
    return;
  }

  // get the response from xhr.response
};

xhr.onprogress = function(event) {
  // report progress
  alert(`Loaded ${event.loaded} of ${event.total}`);
};

xhr.onerror = function() {
  // handle non-HTTP error (e.g. network down)
};
There are actually more events, the modern specification lists them (in the lifecycle order):

loadstart – the request has started.
progress – a data packet of the response has arrived, the whole response body at the moment is in response.
abort – the request was canceled by the call xhr.abort().
error – connection error has occurred, e.g. wrong domain name. Doesn’t happen for HTTP-errors like 404.
load – the request has finished successfully.
timeout – the request was canceled due to timeout (only happens if it was set).
loadend – triggers after load, error, timeout or abort.
The error, abort, timeout, and load events are mutually exclusive. Only one of them may happen.

The most used events are load completion (load), load failure (error), or we can use a single loadend handler and check the properties of the request object xhr to see what happened.

We’ve already seen another event: readystatechange. Historically, it appeared long ago, before the specification settled. Nowadays, there’s no need to use it, we can replace it with newer events, but it can often be found in older scripts.

If we need to track uploading specifically, then we should listen to same events on xhr.upload object.ests were doable since ancient times using <form> or <script> tags, while unsafe were impossible for browsers for a long time.

So, the practical difference is that safe requests are sent right away, with the Origin header, while for the other ones the browser makes a preliminary “preflight” request, asking for permission.

For safe requests:

→ The browser sends the Origin header with the origin.
← For requests without credentials (not sent by default), the server should set:
Access-Control-Allow-Origin to * or same value as Origin
← For requests with credentials, the server should set:
Access-Control-Allow-Origin to same value as Origin
Access-Control-Allow-Credentials to true
Additionally, to grant JavaScript access to any response headers except Cache-Control, Content-Language, Content-Type, Expires, Last-Modified or Pragma, the server should list the allowed ones in Access-Control-Expose-Headers header.

For unsafe requests, a preliminary “preflight” request is issued before the requested one:

→ The browser sends an OPTIONS request to the same URL, with the headers:
Access-Control-Request-Method has requested method.
Access-Control-Request-Headers lists unsafe requested headers.
← The server should respond with status 200 and the headers:
Access-Control-Allow-Methods with a list of allowed methods,
Access-Control-Allow-Headers with a list of allowed headers,
Access-Control-Max-Age with a number of seconds to cache the permissions.
Then the actual request is sent, and the previous “safe” scheme is applied.

Fetch API -- skipped
- provides useful functionalities like tweaking/changing behavior of browser cache wrt fetch requests, or handling redirects.

URL OBJECTS
- create a url -- new URL(url, [base]);
- url.searchParams API has a lot of helpers and handles things like encoding for us (eg. url.searchParams.append(name, value) takes care of encoding)
- Encoding -- chars that are not allowed must be encoded, for eg - latin letters, '&', etc.
- Encoding strings - encodeURI(encodes URL as a whole. For eg. doesn't encode '&' because it treats it as a parameter separator) 
	vs encodeURIComponent (encodes a URL component like search parameter, hash, pathname, etc.)


XMLHTTPRequest
- 