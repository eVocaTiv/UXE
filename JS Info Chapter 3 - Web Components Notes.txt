FROM THE ORBITAL HEIGHT (Introduction)

- There exist many frameworks and development methodologies to build them, each with its own bells and whistles. Usually, special CSS classes and conventions are used to provide “component feel” – CSS scoping and DOM encapsulation.

“Web components” provide built-in browser capabilities for that, so we don’t have to emulate them any more.

Custom elements – to define custom HTML elements.
Shadow DOM – to create an internal DOM for the component, hidden from the others.
CSS Scoping – to declare styles that only apply inside the Shadow DOM of the component.
Event retargeting and other minor stuff to make custom components better fit the development.



CUSTOM ELEMENTS



Custom elements can be of two types:

“Autonomous” – new tags, extending HTMLElement.

Definition scheme:

class MyElement extends HTMLElement {
  constructor() { super(); /* ... */ }
  connectedCallback() { /* ... */ }
  disconnectedCallback() { /* ... */  }
  static get observedAttributes() { return [/* ... */]; }
  attributeChangedCallback(name, oldValue, newValue) { /* ... */ }
  adoptedCallback() { /* ... */ }
 }
customElements.define('my-element', MyElement);
/* <my-element> */
“Customized built-in elements” – extensions of existing elements.

Requires one more .define argument, and is="..." in HTML:

class MyButton extends HTMLButtonElement { /*...*/ }
customElements.define('my-button', MyElement, {extends: 'button'});
/* <button is="my-button"> */
Custom elements are well-supported among browsers. There’s a polyfill

TASK 1 - can revisit later.

SHADOW DOM

Shadow DOM is a way to create a component-local DOM.

shadowRoot = elem.attachShadow({mode: open|closed}) – creates shadow DOM for elem. If mode="open", then it’s accessible as elem.shadowRoot property.
We can populate shadowRoot using innerHTML or other DOM methods.
Shadow DOM elements:

Have their own ids space,
Invisible to JavaScript selectors from the main document, such as querySelector,
Use styles only from the shadow tree, not from the main document.
Shadow DOM, if exists, is rendered by the browser instead of so-called “light DOM” (regular children). In the chapter Shadow DOM slots, composition we’ll see how to compose them.


TEMPLATE ELEMENT

To summarize:

<template> content can be any syntactically correct HTML.
<template> content is considered “out of the document”, so it doesn’t affect anything.
We can access template.content from JavaScript, clone it to reuse in a new component.
The <template> tag is quite unique, because:

The browser checks HTML syntax inside it (as opposed to using a template string inside a script).
…But still allows use of any top-level HTML tags, even those that don’t make sense without proper wrappers (e.g. <tr>).
The content becomes interactive: scripts run, <video autoplay> plays etc, when inserted into the document.
The <template> element does not feature any iteration mechanisms, data binding or variable substitutions, but we can implement those on top of it.


